---
title: "Signac_scATAC"
author: "Hsiao-Yu Peng"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document: default
  html_document:
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(Signac)
library(Seurat)
library(GenomicRanges)
library(ggplot2)
library(patchwork)
```

# Pre-processing workflow
Signac pre-processes chromatin data using two key input files generated by CellRanger:

**1. Peak/Cell Matrix**: Analogous to the gene expression count matrix in scRNA-seq, but with rows representing genome regions (peaks) indicative of open chromatin. Each value shows the number of Tn5 integration sites per cell barcode within each peak. 

**2. Fragment File**: A comprehensive list of unique fragments across all cells. Though larger and stored on-disk, it includes all fragments per cell, not just those mapping to peaks. 

```{r}
counts <- Read10X_h5(filename = "10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5")

metadata <- read.csv(
  file = "10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv",
  header = TRUE,
  row.names = 1
)

chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  fragments = "10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz",
  min.cells = 10,
  min.features = 200
)

pbmc <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata
)

pbmc
```

```{r}
pbmc[['peaks']]

```


```{r}
# see the genomic ranges associated with each feature 
granges(pbmc)

```


We remove features corresponding to chromosome scaffolds (e.g., KI270713.1) or other non-standard sequences to focus on the main biological chromosomes (22 autosomes + X and Y). These non-standard chromosomes often represent assembly artifacts, unplaced contigs, or highly repetitive regions that can introduce noise and do not contribute meaningful biological information to most analyses. Filtering out these features helps streamline the dataset, improve computational efficiency, and enhance the interpretability of results by retaining only the primary chromosomes relevant to the study.

```{r}
peaks.keep <- seqnames(granges(pbmc)) %in% standardChromosomes(granges(pbmc))
pbmc <- pbmc[as.vector(peaks.keep), ]

```


### Adding Gene Annotations

Gene annotations can be added to the `pbmc` object for the human genome to enable downstream functions to access this information directly. 

Ensure that the annotations match the assembly patch used for mapping. For example, the dataset summary shows that 10x Genomics used the "GRCh38-2020-A" reference, corresponding to Ensembl v98. Refer to Ensembl’s site for details on different releases.


```{r}
#if (!require("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")

#BiocManager::install("AnnotationHub")

library(AnnotationHub)
ah <- AnnotationHub()

# Search for the Ensembl 98 EnsDb for Homo sapiens on AnnotationHub
query(ah, "EnsDb.Hsapiens.v98")
```

```{r}
#BiocManager::install("ensembldb")
library(ensembldb)
ensdb_v98 <- ah[["AH75011"]]

```


```{r}
# extract gene annotations from EnsDb

#BiocManager::install("biovizBase")
library(biovizBase)
annotations <- GetGRangesFromEnsDb(ensdb = ensdb_v98)

# change to UCSC style since the data was mapped to hg38
seqlevels(annotations) <- paste0('chr', seqlevels(annotations))
genome(annotations) <- "hg38"
```


```{r}
# add the gene information to the object
Annotation(pbmc) <- annotations
```

# Computing QC Metrics

To assess the quality of scATAC-seq data, the following QC metrics are recommended. Expected values vary based on biological context, cell viability, and other factors.

**1. Nucleosome Banding Pattern**: DNA fragment size histograms should show a distinct nucleosome banding pattern, corresponding to DNA wrapped around a single nucleosome. This is quantified per cell as the nucleosome_signal, indicating the ratio of mononucleosomal to nucleosome-free fragments.

**2. TSS Enrichment Score**: Defined by ENCODE, this score reflects the ratio of fragments centered at transcription start sites (TSS) versus flanking regions. Low TSS enrichment indicates poor-quality data. Use `TSSEnrichment()` to compute this metric, stored in the metadata as `TSS.enrichment`.

**3. Total Fragments in Peaks**: Measures sequencing depth/complexity. Cells with very low or extremely high read counts may indicate low-quality data or artifacts such as doublets or clumps.

**4. Fraction of Fragments in Peaks**: Indicates the proportion of total fragments within peaks. Low values (<15-20%) suggest low-quality cells or artifacts. This metric is sensitive to the peak set used.

**5. Reads in Genomic Blacklist Regions**: ENCODE blacklist regions identify artefactual signal areas. A high fraction of reads mapping to these regions suggests technical artifacts. Use `FractionCountsInRegion()` to calculate this metric per cell.

*Note*: The last three metrics are provided by CellRanger and stored in metadata but can also be computed for non-10x datasets using Signac (see additional documentation for details).


```{r}
# compute nucleosome signal score per cell
pbmc <- NucleosomeSignal(object = pbmc)

# compute TSS enrichment score per cell
pbmc <- TSSEnrichment(object = pbmc)

# add fraction of reads in peaks
pbmc$pct_reads_in_peaks <- pbmc$peak_region_fragments / pbmc$passed_filters * 100

# add blacklist ratio
pbmc$blacklist_ratio <- FractionCountsInRegion(
  object = pbmc,
  assay = 'peaks',
  regions = blacklist_hg38_unified
)
```

Using `DensityScatter()` to visualize the relationship between variables stored in the object metadata. By setting `quantiles=TRUE`, quickly find cutoff values for different. QC metrics

```{r}
DensityScatter(pbmc, x = 'nCount_peaks', y= 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)

```

### Fragment Length Periodicity Analysis

Analyze fragment length periodicity across all cells, grouping by high or low nucleosomal signal strength. Outlier cells (based on mononucleosomal/nucleosome-free ratios) show distinct nucleosomal banding patterns, while remaining cells display patterns typical of a successful ATAC-seq experiment.

```{r}
pbmc$nucleosome_group <- ifelse(pbmc$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
FragmentHistogram(object = pbmc, group.by = 'nucleosome_group')

```

Visualize each QC metrics using a violin plot

```{r}
VlnPlot(
  object = pbmc,
  features = c('nCount_peaks', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal', 'pct_reads_in_peaks'),
  pt.size = 0.1,
  ncol = 5
)

```

Remove outlier cells for these QC metrics.

```{r}
pbmc <- subset(
  x = pbmc,
  subset = nCount_peaks > 9000 &
    nCount_peaks < 100000 &
    pct_reads_in_peaks > 40 &
    blacklist_ratio < 0.01 &
    nucleosome_signal < 4 &
    TSS.enrichment > 4
)
pbmc

```

# Normalization and Linear Dimensional Reduction

**Normalization**: Signac uses TF-IDF normalization, a two-step process correcting for differences in cellular sequencing depth and emphasizing rare peaks by normalizing across cells and peaks.

**Feature Selection**: Due to the low dynamic range of scATAC-seq data, traditional variable feature selection is less effective. The `FindTopFeatures()` function can select the top n% of peaks or exclude features present in fewer than n cells. Here, we use all features, but similar results can be obtained by selecting the top 25% (e.g., `min.cutoff = 'q75'`), leading to faster runtimes. Selected features are automatically set as `VariableFeatures()`.

**Dimension Reduction**: Perform singular value decomposition (SVD) on the TF-IDF matrix, yielding a reduced dimensional representation akin to PCA in scRNA-seq. The combined TF-IDF and SVD steps are known as latent semantic indexing (LSI), introduced for scATAC-seq analysis by Cusanovich et al., 2015.

```{r}
pbmc <- RunTFIDF(pbmc)
pbmc <- FindTopFeatures(pbmc, min.cutoff = 'q0')
pbmc <- RunSVD(pbmc)

```

### Assessing Technical Variation in LSI Components

The first LSI component may capture technical variation (e.g., sequencing depth) instead of biological variation. If so, it should be excluded from downstream analysis. Use the `DepthCor()` function to evaluate the correlation between LSI components and sequencing depth.

```{r}
DepthCor(pbmc)
```


#  Non-linear dimension reduction and clustering

With cells embedded in a low-dimensional space, standard scRNA-seq analysis methods can be used for graph-based clustering and non-linear dimension reduction. The `RunUMAP()`, `FindNeighbors()`, and `FindClusters()` functions from the Seurat package facilitate these processes.

```{r}
pbmc <- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)
pbmc <- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)
pbmc <- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)
DimPlot(object = pbmc, label = TRUE) + NoLegend()

```

# Create a gene activity matrix

Annotating clusters in scATAC-seq is challenging due to limited knowledge about noncoding regions. To quantify gene activity, chromatin accessibility linked to each gene can be assessed, creating a gene activity assay.

A simple method involves summing fragments intersecting the gene body and promoter region. Gene coordinates are extended by 2 kb upstream to include promoter accessibility, and the `FeatureMatrix()` function counts fragments mapping to these regions for each cell. The `GeneActivity()` function automates these steps. `Cicero` is an alternative tool for similar analysis, and a Signac workflow vignette is available for guidance.

```{r}
gene.activities <- GeneActivity(pbmc)

# add the gene activity matrix to the Seurat object as a new assay and normalize it
pbmc[['RNA']] <- CreateAssayObject(counts = gene.activities)
pbmc <- NormalizeData(
  object = pbmc,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(pbmc$nCount_RNA)
)

```


### Visualizing Gene Activity for Cluster Interpretation

Visualize canonical marker gene activities to interpret ATAC-seq clusters. Note that these activities are noisier than scRNA-seq data due to sparse chromatin measurements and assumptions about gene body/promoter accessibility correlating with expression. Despite this, monocytes, B, T, and NK cell populations can be identified, though further subdivision is difficult with supervised analysis alone.


```{r}
DefaultAssay(pbmc) <- 'RNA'

FeaturePlot(
  object = pbmc,
  features = c('MS4A1', 'CD3D', 'LEF1', 'NKG7', 'TREM1', 'LYZ'),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)

```


# Integrating with scRNA-seq data

To interpret scATAC-seq data, cells can be classified using scRNA-seq data from the same biological system (e.g., human PBMCs). Cross-modality integration and label transfer methods are used to identify shared patterns between the gene activity matrix and scRNA-seq dataset, matching biological states across modalities and providing classification scores for each cell.

```{r}
# Load the pre-processed scRNA-seq data for PBMCs
pbmc_rna <- readRDS("pbmc_10k_v3.rds")
pbmc_rna <- UpdateSeuratObject(pbmc_rna)

```


```{r}
transfer.anchors <- FindTransferAnchors(
  reference = pbmc_rna,
  query = pbmc,
  reduction = 'cca'
)

```

```{r}
predicted.labels <- TransferData(
  anchorset = transfer.anchors,
  refdata = pbmc_rna$celltype,
  weight.reduction = pbmc[['lsi']],
  dims = 2:30
)

```

```{r}
pbmc <- AddMetaData(object = pbmc, metadata = predicted.labels)
```

```{r}
plot1 <- DimPlot(
  object = pbmc_rna,
  group.by = 'celltype',
  label = TRUE,
  repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')

plot2 <- DimPlot(
  object = pbmc,
  group.by = 'predicted.id',
  label = TRUE,
  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq')

plot1 + plot2

```

The scRNA-based classifications align with the UMAP visualization from scATAC-seq data. However, a small cell population is identified as platelets, which is unexpected since platelets lack nuclei and should not be detected by scATAC-seq. These cells may be platelet-precursor megakaryocytes, typically found in bone marrow and rarely in peripheral blood. Given their extreme rarity in normal bone marrow (< 0.1%), this explanation is unlikely.


### A closer look at teh "platelets"

Plotting the prediction scores for cell labels shows that “platelet” cells had relatively low scores (< 0.8), indicating low confidence in their assigned identity. Often, the next most likely predicted identity for these cells was “CD4 naive”.

```{r}
VlnPlot(pbmc, 'prediction.score.max', group.by = 'predicted.id')

```

```{r}
# Identify the metadata columns that start with "prediction.score."
metadata_attributes <- colnames(pbmc[[]])
prediction_score_attributes <- grep("^prediction.score.", metadata_attributes, value = TRUE)
prediction_score_attributes <- setdiff(prediction_score_attributes, "prediction.score.max")

# Extract the prediction score attributes for these cells
predicted_platelets <- which(pbmc$predicted.id == "Platelet")
platelet_scores <- pbmc[[]][predicted_platelets, prediction_score_attributes]

# Order the columns by their average values in descending order
ordered_columns <- names(sort(colMeans(platelet_scores, na.rm = TRUE), decreasing = TRUE))
ordered_platelet_scores_df <- platelet_scores[, ordered_columns]

print(ordered_platelet_scores_df)


```



### Filtering Rare Cell States

Due to the very small number of cells classified as “platelets” (< 20), determining their precise identity is challenging. Larger datasets would be needed for confident peak identification and proper annotation. For downstream analysis, we will remove these rare cell states, keeping only cell annotations with more than 20 cells.

```{r}
predicted_id_counts <- table(pbmc$predicted.id)

# Identify the predicted.id values that have more than 20 cells
major_predicted_ids <- names(predicted_id_counts[predicted_id_counts > 20])
pbmc <- pbmc[, pbmc$predicted.id %in% major_predicted_ids]

```


### Reassigning Cell Identities for Analysis

For downstream analyses, cell identities can be reassigned from their UMAP cluster index to the predicted per-cell labels. Alternatively, merging cluster indexes with predicted labels can also be considered.

```{r}
# change cell identities to the per-cell predicted labels
Idents(pbmc) <- pbmc$predicted.id
```


# Find differentially accessible peaks between cell types

To identify differentially accessible regions between cell clusters, a differential accessibility (DA) test can be performed. A straightforward method is the Wilcoxon rank sum test, which can be run efficiently on a Seurat object using the `presto` package.

```{r}
# install presto
if (!requireNamespace("remotes", quietly = TRUE))
  install.packages('remotes')
remotes::install_github('immunogenomics/presto')
```


Here we focus on Naive CD4 cells and CD14 monocytes, but other cells can compared using the same method.

```{r}
# change back to working with peaks instead of gene activities
DefaultAssay(pbmc) <- 'peaks'

# wilcox is the default option for test.use
da_peaks <- FindMarkers(
  object = pbmc,
  ident.1 = "CD4 Naive",
  ident.2 = "CD14+ Monocytes",
  test.use = 'wilcox',
  min.pct = 0.1
)

head(da_peaks)

```


```{r}
plot1 <- VlnPlot(
  object = pbmc,
  features = rownames(da_peaks)[1],
  pt.size = 0.1,
  idents = c("CD4 Naive","CD14+ Monocytes")
)
plot2 <- FeaturePlot(
  object = pbmc,
  features = rownames(da_peaks)[1],
  pt.size = 0.1
)

plot1 | plot2

```


The `ClosestFeature()` function helps by identifying the nearest gene to each peak because interpreting peak coordinates can be challenging. 

```{r}
open_cd4naive <- rownames(da_peaks[da_peaks$avg_log2FC > 3, ])
open_cd14mono <- rownames(da_peaks[da_peaks$avg_log2FC < -3, ])

closest_genes_cd4naive <- ClosestFeature(pbmc, regions = open_cd4naive)
closest_genes_cd14mono <- ClosestFeature(pbmc, regions = open_cd14mono)

print(head(closest_genes_cd4naive))
print(head(closest_genes_cd14mono))
```


## GO enrichment analysis with clusterProfiler

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)
library(enrichplot)
cd4naive_ego <- enrichGO(gene = closest_genes_cd4naive$gene_id,
                keyType = "ENSEMBL",
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                qvalueCutoff = 0.05,
                readable = TRUE)

barplot(cd4naive_ego,showCategory = 20)


cd14mono_ego <- enrichGO(gene = closest_genes_cd14mono$gene_id,
                keyType = "ENSEMBL",
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                qvalueCutoff = 0.05,
                readable = TRUE)

barplot(cd14mono_ego,showCategory = 20)
```


# Plotting genomic regions

The `CoveragePlot()` function allows plotting the frequency of Tn5 integration across genomic regions for groups of cells (e.g., by cluster or cell type) using metadata stored in the object. These plots create pseudo-bulk accessibility tracks by averaging signals from all cells in a group, showing DNA accessibility in a region. Additional elements like gene annotations, peak coordinates, and genomic links can also be visualized. For details, refer to the visualization vignette.

To enhance plotting, related cell types can be grouped by running the `SortIdents()` function to sort plotting order by similarities among annotated cell types.

```{r}
pbmc <- SortIdents(pbmc)

```


### Visualizing DA Peaks for Key Marker Genes

We can visualize DA peaks open in CD4 naive cells and CD14 monocytes near key marker genes, such as CD4 and LYZ, respectively. Here we highlight the DA peaks regions in grey.

```{r}
# find DA peaks overlapping gene of interest
regions_highlight <- subsetByOverlaps(StringToGRanges(open_cd4naive), LookupGeneCoords(pbmc, "CD4"))

CoveragePlot(
  object = pbmc,
  region = "CD4",
  region.highlight = regions_highlight,
  extend.upstream = 1000,
  extend.downstream = 1000
)

```


```{r}
regions_highlight <- subsetByOverlaps(StringToGRanges(open_cd14mono), LookupGeneCoords(pbmc, "LYZ"))

CoveragePlot(
  object = pbmc,
  region = "LYZ",
  region.highlight = regions_highlight,
  extend.upstream = 1000,
  extend.downstream = 5000
)

```




